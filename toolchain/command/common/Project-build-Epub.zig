const std = @import("std");
const builtin = @import("builtin");

const tmd = @import("tmd");
const list = @import("list");

const AppContext = @import("AppContext.zig");
const DocRenderer = @import("DocRenderer.zig");
const Project = @import("Project.zig");
const Config = @import("Config.zig");
const gen = @import("gen.zig");
const util = @import("util.zig");
const Zip = @import ("Zip.zig");


const miniz = @cImport({
    @cInclude("miniz.h");
});

const bufferSize = Project.maxTmdFileSize * 8;

const maxAssetFileSize = 1 << 22; // 4M

const initZipCapacity = 1 << 23; // 8M

const BuildSession = Project.BuildSession(@This());

session: *BuildSession,
genBuffer: []u8,
zip: Zip,

const contentFolderName = "OEBPS";
const opfFilePath = contentFolderName ++ "/package.opf";

pub fn buildNameSuffix() []const u8 {
    return ".epub";
}

pub fn init(session: *BuildSession) !@This() {
    return .{
        .session = session,
        .genBuffer = try session.arenaAllocator.alloc(u8, bufferSize),
        .zip = try .init(initZipCapacity),
    };
}

pub fn deinit(builder: *@This()) void {
    builder.zip.deinit();
}

pub fn init2(builder: *@This()) !void {
    try builder.writeEpubMimeTypeFile();
    try builder.writeEpubMetaInfoFile();
}

pub fn build(builder: *@This()) !void {
    try builder.renderArticles();

    try builder.writeRemainingFilesInEpub();

    const epubData = try builder.zip.finalize();
    try util.writeFile(null, builder.session.buildOutputPath, epubData);
}

fn writeEpubMimeTypeFile(builder: *@This()) !void {
    const filepath = "mimetype";
    const content = "application/epub+zip";
    try builder.zip.addFile(filepath, content, false);
}

fn writeEpubMetaInfoFile(builder: *@This()) !void {
    const filepath = "META-INF/container.xml";
    const content =
        \\<?xml version="1.0" encoding="UTF-8"?>
        \\<container version="1.0" xmlns="urn:oasis:names:tc:opendocument:xmlns:container">
        \\<rootfiles>
        \\    <rootfile full-path="
        ++
        opfFilePath
        ++
        \\" media-type="application/oebps-package+xml" />
        \\</rootfiles>
        \\</container>
        ;
    try builder.zip.addFile(filepath, content, true);
}

fn writeRemainingFilesInEpub(builder: *@This()) !void {
    const session = builder.session;

    const coverPagePath = if (session.coverImageIndex) |index| blk: {
        const imagePath = session.imageFiles.items[index];

        var fba = std.heap.FixedBufferAllocator.init(builder.genBuffer);
        const fbaAllocator = fba.allocator();
        var wa: std.Io.Writer.Allocating = .init(fbaAllocator);
        try wa.writer.writeAll(
            \\<?xml version="1.0" encoding="utf-8"?>
            \\<!DOCTYPE html>
            \\<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="en">
            \\<head>
            \\<title>
        );

        try tmd.writeHtmlContentText(&wa.writer, session.project.title());

        try wa.writer.print(
            \\</title>
            \\<style>
            \\ body {{ margin: 0; padding: 0; text-align: center; }}
            \\ img {{ max-width: 100%; max-height: 100vh; }}
            \\</style>
            \\</head>
            \\<body>
            \\<img src="{s}"/>
            \\</body>
            \\</html>
            , .{imagePath[contentFolderName.len+1..]}
        );

        const pagePath = contentFolderName ++ "/cover.xhtml";
        try builder.zip.addFile(pagePath, wa.written(), true);
        break :blk pagePath;
    } else null;

    const navPagePath = contentFolderName ++ "/nav.xhtml";
    {
        var fba = std.heap.FixedBufferAllocator.init(builder.genBuffer);
        const fbaAllocator = fba.allocator();
        var wa: std.Io.Writer.Allocating = .init(fbaAllocator);

        try wa.writer.writeAll(
            \\<?xml version="1.0" encoding="UTF-8"?>
            \\<!DOCTYPE html>
            \\<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
            \\<head>
            \\<title>
        );

        try tmd.writeHtmlContentText(&wa.writer, session.project.title());

        try wa.writer.writeAll(
            \\</title>
            \\</head>
            \\<body>
            \\<nav epub:type="toc">
            \\
        );

        switch (session.navArticleInfo) {
            .manuallySpecified => |info| {
                //try session.renderTmdDoc(&wa.writer, .{
                //    .doc = &info.tmdDoc,
                //    .sourceFilePath = session.articleFiles.items[0],
                //    .targetFilePath = navPagePath,
                //}, false);
                _ = info;
            },
            .autoGenerated => {
                // ToDo:
            },
        }

        try wa.writer.writeAll(
            \\</nav>
            \\</body>
            \\</html>
        );

        try builder.zip.addFile(navPagePath, wa.written(), true);
    }

    {
        var fba = std.heap.FixedBufferAllocator.init(builder.genBuffer);
        const fbaAllocator = fba.allocator();
        var wa: std.Io.Writer.Allocating = .init(fbaAllocator);

        // ToDo: some properties need to change.
        try wa.writer.writeAll(
            \\<?xml version="1.0" encoding="UTF-8"?>
            \\<package xmlns="http://www.idpf.org/2007/opf" unique-identifier="pub-id" version="3.0">
            \\ <metadata xmlns:dc="http://purl.org/dc/elements/1.1/">
            \\  <dc:identifier id="pub-id">urn:uuid:1f3f036c-17dd-4a5f-9157-b346d78d0ae3</dc:identifier>
            \\  <dc:title>Go 101</dc:title>
            \\  <dc:language>en</dc:language>
            \\  <dc:creator id="creator">Tapir Liu</dc:creator>
            \\  <meta refines="#creator" property="role" scheme="marc:relators" id="role">aut</meta>
            \\  <meta property="dcterms:modified">2025-08-15T20:40:33Z</meta>
            \\ </metadata>
            \\ <manifest>
            \\
        );

        try wa.writer.print(
            \\  <item id="nav" href="{s}" media-type="application/xhtml+xml" properties="nav"></item>
            \\
            , .{navPagePath[contentFolderName.len+1..]});

        for (session.articleFiles.items, 0..) |absPath, index| {
            const targetPath = session.fileMapping.get(.{ .local = absPath }) orelse return error.ArticleNotRegistered;
            try wa.writer.print(
                \\  <item id="article-{}" href="{s}" media-type="application/xhtml+xml"></item>
                \\
                , .{index, targetPath[contentFolderName.len+1..]});
        }
        if (coverPagePath) |targetPath| {
            try wa.writer.print(
                \\  <item id="cover" href="{s}" media-type="application/xhtml+xml"></item>
                \\
                , .{targetPath[contentFolderName.len+1..]});
        }
        for (session.imageFiles.items, 0..) |targetPath, index| {
            const ext = tmd.extension(targetPath) orelse unreachable;
            const info = tmd.getExtensionInfo(ext);
            std.debug.assert(info.isImage);

            const extra = if (index != session.coverImageIndex) "" else
                \\ properties="cover-image"
                ;
            try wa.writer.print(
                \\  <item id="image-{}" href="{s}" media-type="{s}"{s}></item>
                \\
                , .{index, targetPath[contentFolderName.len+1..], info.mime, extra});
        }
        if (session.cssFiles.head) |head| {
            var index: usize = 0;
            var element = head;
            while (true) {
                const next = element.next;
                const targetPath = element.value;

                try wa.writer.print(
                    \\  <item id="css-{}" href="{s}" media-type="text/css"></item>
                    \\
                    , .{index, targetPath[contentFolderName.len+1..]});

                index += 1;
                if (next) |n| element = n else break;
            }
        }
        if (session.jsFiles.head) |head| {
            var index: usize = 0;
            var element = head;
            while (true) {
                const next = element.next;
                const targetPath = element.value;

                try wa.writer.print(
                    \\  <item id="js-{}" href="{s}" media-type="application/javascript"></item>
                    \\
                    , .{index, targetPath[contentFolderName.len+1..]});

                index += 1;
                if (next) |n| element = n else break;
            }
        }

        try wa.writer.writeAll(
            \\ </manifest>
            \\ <spine>
            \\
        );

        if (coverPagePath) |_| {
            try wa.writer.writeAll(
                \\  <itemref idref="cover"></itemref>
                \\
                );
        }
        for (0..session.articleFiles.items.len) |index| {
            try wa.writer.print(
                \\  <itemref idref="article-{}"></itemref>
                \\
                , .{index});
        }
        
        try wa.writer.writeAll(
            \\ </spine>
            \\</package>
        );

        try builder.zip.addFile(opfFilePath, wa.written(), true);
    }

    // epub 3+ don't need toc.ncx file.
    // ToDo: support epub 2.x.
}

pub fn calTargetFilePath(builder: *@This(), filePath: Config.FilePath, filePurpose: Project.FilePurpose) !struct{[]const u8, bool} {
    const session = builder.session;
    switch (filePurpose) {
        .article => {
            switch (filePath) {
                .local => |sourceAbsPath| {
                    const project = session.project;
                    if (!util.isFileInDir(sourceAbsPath, project.path)) {
                        try session.appContext.stderr.print("Article file must be in project path ({s}): {s}.\n", .{ session.project.path, sourceAbsPath });
                        return error.FileOutOfProject;
                    }

                    const relPath = sourceAbsPath[project.path.len + 1 ..];
                    const ext = std.fs.path.extension(relPath);
                    const targetPath = try util.buildEpubFilePath(contentFolderName ++ "/xhtml/", relPath[0 .. relPath.len - ext.len], ".xhtml", session.arenaAllocator);
                    if (builtin.mode == .Debug) std.debug.assert(session.targetFileContents.get(targetPath) == null);

                    //try session.targetFileContents.put(targetPath, ""); // Don't
                    return .{targetPath, true};
                },
                .builtin, .remote => unreachable,
            }
        },
        //.html => {
        //    const project = session.project;
        //    if (!util.isFileInDir(sourceAbsPath, project.path)) {
        //        try session.appContext.stderr.print("Article file must be in project path ({s}): {s}.\n", .{ session.project.path, sourceAbsPath });
        //        return error.FileOutOfProject;
        //    }
        //    const relPath = sourceAbsPath[project.path.len + 1 ..];
        //    const ext = std.fs.path.extension(relPath);
        //    const targetPath = util.buildEpubFilePath("html/", relPath[0 .. relPath.len - ext.len], ".xhtml", session.arenaAllocator);
        //
        //    if (builtin.mode == .Debug) std.debug.assert(session.targetFileContents.get(targetPath) == null);
        //    //try session.targetFileContents.put(targetPath, ""); // Don't
        //
        //    return .{targetPath, true};
        //},
        inline .images, .css, .js => |tag| {
            const folderName = contentFolderName ++ "/" ++ @tagName(tag) ++ "/";

            const compressIt = tag != .images;
            switch (filePath) {
                .builtin => |name| {
                    const info = try session.appContext.getBuiltinFileInfo(name);

                    const targetPath = try util.buildEpubFilePathWithContentHashBase64(folderName, name, info.content, session.arenaAllocator);
                    if (builtin.mode == .Debug) std.debug.assert(session.targetFileContents.get(targetPath) == null);

                    try builder.zip.addFile(targetPath, info.content, compressIt);

                    if (builtin.mode == .Debug) std.debug.assert(session.targetFileContents.get(targetPath) == null);
                    try session.targetFileContents.put(targetPath, info.content);
                    return .{targetPath, true};
                },
                .local => |sourceAbsPath| {
                    const content = try util.readFile(std.fs.cwd(), sourceAbsPath, .{ .alloc = .{ .allocator = session.arenaAllocator, .maxFileSize = maxAssetFileSize } }, session.appContext.stderr);

                    const targetPath = try util.buildEpubFilePathWithContentHashBase64(folderName, std.fs.path.basename(sourceAbsPath), content, session.arenaAllocator);
                    if (session.targetFileContents.get(targetPath) == null) {
                        try builder.zip.addFile(targetPath, content, compressIt);
                        try session.targetFileContents.put(targetPath, content);
                        return .{targetPath, true};
                    }

                    return .{targetPath, false};
                },
                .remote => unreachable,
            }
        },
    }
}

fn renderArticles(builder: *@This()) !void {
    try builder.session.renderArticles('/', builder.genBuffer, builder);
}

pub fn makeCachedArticleContent(builder: *@This(), targetFilePath: []const u8, htmlContent: []const u8) ![]const u8 {
    try builder.zip.addFile(targetFilePath, htmlContent, true);

    //const htmlContent2 = try session.arenaAllocator.dupe(u8, htmlContent);
    //return htmlContent2;
    return ""; // ToDo: when nav is .autoGenerated, the content needs to be cached to output later.
}
