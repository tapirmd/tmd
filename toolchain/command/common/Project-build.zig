const std = @import("std");
const builtin = @import("builtin");

const tmd = @import("tmd");
const list = @import("list");

const AppContext = @import("AppContext.zig");
const DocRenderer = @import("DocRenderer.zig");
const FileIterator = @import("FileIterator.zig");
const Project = @import("Project.zig");
const Config = @import("Config.zig");
const gen = @import("gen.zig");
const util = @import("util.zig");

pub fn build(project: *const Project, ctx: *AppContext, BuilderType: type) !void {
    var session: BuildSession = .init(project, ctx, .init(ctx.allocator));
    defer session.deinit();
    try session.buildWith(BuilderType);
}

const maxTmdFileSize = 1 << 20; // 1M
const bufferSize = maxTmdFileSize * 8;

const maxAssetFileSize = 1 << 22; // 4M

const BuildSession = struct {
    project: *const Project,
    appContext: *AppContext,
    _arenaAllocator: std.heap.ArenaAllocator,

    arenaAllocator: std.mem.Allocator = undefined,

    projectVersion: []const u8 = undefined,
    buildOutputPath: []const u8 = undefined,
    buildOutputDir: std.fs.Dir = undefined,

    genBuffer: []u8 = undefined,

    calTargetFilePath: *const fn (*BuildSession, Config.FilePath, FilePurpose) anyerror![]const u8 = undefined,
    generateArticleContent: *const fn (*BuildSession, []const u8, []const u8, *DocRenderer) anyerror![]const u8 = undefined,

    //builderContext: *anyopaque = undefined,

    // source file-path to target relative-file-path
    fileMapping: std.HashMap(Config.FilePath, []const u8, Config.FilePath.HashMapContext, 33) = undefined,

    // target relative-file-path to cached file content.
    // For website mode, asset files (iamge, css, etc.) are not cached.
    // ToDo: maybe, website mode should not cache article html too.
    // ToDo2: maybe, no file content should be cached at all (for all modes).
    targetFileContents: std.StringHashMap([]const u8) = undefined,

    // source abs-file-path
    articleFiles: std.ArrayList([]const u8) = .empty,
    navArticleInfo: union(enum) {
        manuallySpecified: struct {
            collected: bool, // whether or not the nav doc is collected
            tmdDoc: tmd.Doc,
        },
        autoGenerated: struct {
            index: usize, // the index of the next article to be collect
            tocItemBuffer: std.Io.Writer.Allocating,
        },
    } = undefined,

    // ToDo: not all build modes needs these.
    //       For epub mode, they are used to write package.opf files.
    //       It is best to put them in Builder specified sessions.
    // target relative-file-path
    htmlFiles: std.ArrayList([]const u8) = .empty,
    cssFiles: list.List([]const u8) = .{},
    jsFiles: list.List([]const u8) = .{},
    imageFiles: std.ArrayList([]const u8) = .empty,
    coverImageIndex: ?usize = null,

    fn init(project: *const Project, appContext: *AppContext, arenaAllocator: std.heap.ArenaAllocator) @This() {
        return .{
            .project = project,
            .appContext = appContext,
            ._arenaAllocator = arenaAllocator,
        };
    }

    fn deinit(self: *@This()) void {
        self._arenaAllocator.deinit();
    }

    fn buildWith(self: *@This(), BuilderType: type) !void {
        self.arenaAllocator = self._arenaAllocator.allocator();

        try self.confirmProjectVersion();
        try self.confirmBuildOutputPath(BuilderType.buildNameSuffix());

        try std.fs.cwd().deleteTree(self.buildOutputPath);
        self.buildOutputDir = try std.fs.cwd().makeOpenPath(self.buildOutputPath, .{});
        defer self.buildOutputDir.close();

        self.genBuffer = try self.arenaAllocator.alloc(u8, bufferSize);

        self.calTargetFilePath = BuilderType.calTargetFilePath;
        self.generateArticleContent = BuilderType.generateArticleContent;

        //BuilderType.initContextFor(self);
        //defer BuilderType.deinitContextFor(self);

        self.fileMapping = .init(self.arenaAllocator);
        self.targetFileContents = .init(self.arenaAllocator);

        var tmdDocRenderer: DocRenderer = .init(
            self.appContext,
            self.project.configEx,
            BuilderType.createDocRendererCallbacks(self),
        );

        // Some images must be collected before articles.
        try self.collectSomeImages();
        try self.collectCssFiles();
        try self.collectJsFiles();
        try self.collectArticles(&tmdDocRenderer);

        try BuilderType.assembleOutputFiles(self);

        std.debug.print("Done. Output directory: {s}\n", .{self.buildOutputPath});
    }

    fn confirmProjectVersion(self: *@This()) !void {
        const project = self.project;
        self.projectVersion = if (project.configEx.basic.@"project-version") |option| blk: {
            const version = std.mem.trim(u8, option.data, " \t");
            if (std.mem.eql(u8, version, "@git-commit")) {
                break :blk AppContext.getLastGitCommitString(project.path, self.arenaAllocator);
            } else break :blk version;
        } else "";
    }

    fn confirmBuildOutputPath(self: *@This(), buildNameSuffix: []const u8) !void {
        const project = self.project;

        var buffer: [std.fs.max_path_bytes]u8 = undefined;
        var w: std.Io.Writer = .fixed(&buffer);

        try w.writeAll(project.workspacePath);
        try w.writeByte(std.fs.path.sep);
        try w.writeAll(AppContext.buildOutputDirname);
        try w.writeByte(std.fs.path.sep);
        if (project.path.len != project.workspacePath.len) {
            try w.writeAll("@projects");
            try w.writeByte(std.fs.path.sep);
        }
        try w.writeAll(project.dirname());
        if (self.projectVersion.len > 0) {
            try w.writeByte('-');
            try w.writeAll(self.projectVersion);
        }
        try w.writeAll(buildNameSuffix);

        self.buildOutputPath = try self.arenaAllocator.dupe(u8, w.buffered());

        //std.debug.print("self.buildOutputPath = {s}\n", .{self.buildOutputPath});
    }

    fn collectArticles(self: *@This(), tmdDocRenderer: *DocRenderer) !void {
        // Note that: in epub build,
        // the navigation file may be also used as a general article file.
        // This means the file might be rendered as two HTML files.

        if (self.project.navigationArticlePath()) |path| {
            if (!std.mem.eql(u8, std.fs.path.extension(path), ".tmd")) {
                try self.appContext.stderr.print("Navigation file must be a .tmd extension: {s}\n", .{path});
                return error.BadNavigationFile;
            }

            const absPath = try util.resolveRealPath2(self.project.path, path, true, self.arenaAllocator);
            if (!util.isFileInDir(absPath, self.project.path)) {
                try self.appContext.stderr.print("Navigation file must be in project path ({s}): {s}.\n", .{ self.project.path, absPath });
                return error.BadNavigationFile;
            }

            const index = self.articleFiles.items.len;
            _ = try self.tryToRegisterFile(.{ .local = absPath }, .navigationArticle);
            std.debug.assert(index + 1 == self.articleFiles.items.len);

            self.navArticleInfo = .{
                .manuallySpecified = .{
                    .collected = false,
                    .tmdDoc = blk: {
                        const tmdContent = try util.readFile(std.fs.cwd(), absPath, .{ .alloc = .{ .allocator = self.arenaAllocator, .maxFileSize = maxTmdFileSize } }, self.appContext.stderr);
                        break :blk try tmd.Doc.parse(tmdContent, self.arenaAllocator);
                    },
                },
            };
        } else {
            var fi: FileIterator = .init(&.{self.project.path}, self.appContext.allocator, self.appContext.stderr, &AppContext.excludeSpecialDir);
            while (try fi.next()) |entry| {
                if (!std.mem.eql(u8, std.fs.path.extension(entry.filePath), ".tmd")) continue;

                const path = try util.resolveRealPath2(entry.dirPath, entry.filePath, false, self.arenaAllocator);
                _ = try self.tryToRegisterFile(.{ .local = path }, .contentArticle);
            }

            self.navArticleInfo = .{
                .autoGenerated = .{
                    .index = 0,
                    .tocItemBuffer = try .initCapacity(self.arenaAllocator, 1 << 16), // 64KIB
                },
            };
        }

        var i: usize = 0;
        while (i < self.articleFiles.items.len) {
            _ = try self.collectArticle(self.articleFiles.items[i], tmdDocRenderer);
            i += 1;
        }
    }

    // An article must be registered before being collected.
    fn collectArticle(self: *@This(), absPath: []const u8, tmdDocRenderer: *DocRenderer) !void {
        const targetPath = self.fileMapping.get(.{ .local = absPath }) orelse return error.ArticleNotRegistered;
        if (self.targetFileContents.get(targetPath)) |_| return error.ArticleAlreadyCollected;

        // ToDo: not always need to cache the content, just output it directly.
        const htmlContent = try self.generateArticleContent(self, absPath, targetPath, tmdDocRenderer);
        try self.targetFileContents.put(targetPath, htmlContent);
    }

    fn collectSomeImages(self: *@This()) !void {
        if (self.project.coverImagePath()) |path| {
            const absPath = try util.resolveRealPath2(self.project.path, path, true, self.arenaAllocator);

            const index = self.imageFiles.items.len;
            _ = try self.tryToRegisterFile(.{ .local = absPath }, .images);
            std.debug.assert(index + 1 == self.imageFiles.items.len);
            self.coverImageIndex = index;
        }

        if (self.project.configEx.basic.favicon) |option| {
            const absPath = option._parsed;

            _ = try self.tryToRegisterFile(absPath, .images);
        }
    }

    fn collectCssFiles(self: *@This()) !void {
        if (self.project.configEx.basic.@"css-files") |option| {
            const paths = option._parsed;

            var element = paths.head;
            while (element) |e| {
                const filePath = e.value;
                _ = try self.tryToRegisterFile(filePath, .css);
                element = e.next;
            }
        }
    }

    fn collectJsFiles(self: *@This()) !void {
        if (self.project.configEx.basic.@"js-files") |option| {
            const paths = option._parsed;

            var element = paths.head;
            while (element) |e| {
                const filePath = e.value;
                _ = try self.tryToRegisterFile(filePath, .js);
                element = e.next;
            }
        }
    }

    pub fn tryToRegisterFile(self: *@This(), filePath: Config.FilePath, filePurpose: FilePurpose) ![]const u8 {
        const targetPath = switch (filePath) {
            .builtin => |name| blk: {
                if (self.fileMapping.get(filePath)) |targetPath| return targetPath;

                const info = try self.appContext.getBuiltinFileInfo(name);
                switch (filePurpose) {
                    .images => {
                        const extInfo = tmd.getExtensionInfo(info.extension);
                        if (!extInfo.isImage) return error.NonImageBuiltinAssertUsedAsImage;
                    },
                    .css => if (info.extension != .css) return error.NonCssBuiltinAssertUsedAsCss,
                    else => return error.NoSuchBuiltinAssets,
                }

                const targetPath = try self.calTargetFilePath(self, filePath, filePurpose);
                try self.fileMapping.put(filePath, targetPath);

                switch (filePurpose) {
                    .images => try self.imageFiles.append(self.arenaAllocator, targetPath),
                    .css => {
                        const element = try self.cssFiles.createElement(self.arenaAllocator, true);
                        element.value = targetPath;
                    },
                    else => unreachable,
                }

                break :blk targetPath;
            },
            .remote => |url| url,
            .local => |absPath| blk: {
                if (self.fileMapping.get(filePath)) |targetPath| return targetPath;

                const targetPath = try self.calTargetFilePath(self, filePath, filePurpose);
                try self.fileMapping.put(filePath, targetPath);

                switch (filePurpose) {
                    .navigationArticle, .contentArticle => try self.articleFiles.append(self.arenaAllocator, absPath),
                    else => {}, // handle below
                }

                switch (filePurpose) {
                    .navigationArticle, .contentArticle => {}, // handled above
                    //.html => try self.htmlFiles.append(self.arenaAllocator, targetPath),
                    .images => try self.imageFiles.append(self.arenaAllocator, targetPath),
                    .css => {
                        const element = try self.cssFiles.createElement(self.arenaAllocator, true);
                        element.value = targetPath;
                    },
                    .js => {
                        const element = try self.jsFiles.createElement(self.arenaAllocator, true);
                        element.value = targetPath;
                    },
                }

                break :blk targetPath;
            },
        };

        if (builtin.mode == .Debug and false) {
            switch (filePath) {
                .remote => |url| {
                    std.debug.print(
                        \\[register] {s}: {s}
                        \\
                    , .{ @tagName(filePurpose), url });
                },
                inline .builtin, .local => |absPathOrName| {
                    if (targetPath.len <= 128) std.debug.print(
                        \\[register] {s}: {s}
                        \\    -> {s}
                        \\
                    , .{ @tagName(filePurpose), absPathOrName, targetPath }) else std.debug.print(
                        \\[register] {s}: {s}
                        \\    -> {s}... ({} bytes)
                        \\
                    , .{ @tagName(filePurpose), absPathOrName, targetPath[0..64], targetPath.len });
                },
            }
        }

        return targetPath;
    }

    fn writeAssetElementLinksInHead(self: *@This(), w: *std.Io.Writer, docTargetFilePath: []const u8, sep: u8) !void {
        if (self.project.configEx.basic.favicon) |option| {
            const faviconPath = option._parsed;
            try gen.writeFaviconAssetInHead(w, faviconPath, self, docTargetFilePath, sep);
        }

        if (self.project.configEx.basic.@"css-files") |option| {
            const cssFiles = option._parsed;

            if (cssFiles.head) |head| {
                var element = head;
                while (true) {
                    const next = element.next;
                    const cssFilePath = element.value;

                    try gen.writeCssAssetInHead(w, cssFilePath, self, docTargetFilePath, sep);

                    if (next) |nxt| element = nxt else break;
                }
            }
        }

        if (self.project.configEx.basic.@"js-files") |option| {
            const jsFiles = option._parsed;

            if (jsFiles.head) |head| {
                var element = head;
                while (true) {
                    const next = element.next;
                    const jsFilePath = element.value;

                    try gen.writeJsAssetInHead(w, jsFilePath, self, docTargetFilePath, sep);

                    if (next) |nxt| element = nxt else break;
                }
            }
        }
    }
};

const TmdGenCustomHandler = struct {
    const MutableData = struct {
        relativePathWriter: gen.RelativePathWriter = undefined,
        externalBlockGenerator: gen.ExternalBlockGenerator = undefined,
    };

    session: *BuildSession,
    tmdDocInfo: DocRenderer.TmdDocInfo,
    mutableData: *MutableData,

    fn init(bs: *BuildSession, tmdDocInfo: DocRenderer.TmdDocInfo, mutableData: *MutableData) TmdGenCustomHandler {
        return .{
            .session = bs,
            .tmdDocInfo = tmdDocInfo,
            .mutableData = mutableData,
        };
    }

    fn makeTmdGenOptions(handler: *const @This()) tmd.GenOptions {
        return .{
            .callbackContext = handler,
            .getCustomBlockGenCallback = getCustomBlockGenCallback,
            .getMediaUrlGenCallback = getMediaUrlGenCallback,
            .getLinkUrlGenCallback = getLinkUrlGenCallback,
        };
    }

    fn getCustomBlockGenCallback(ctx: *const anyopaque, custom: *const tmd.BlockType.Custom) !?tmd.GenCallback {
        const handler: *const @This() = @ptrCast(@alignCast(ctx));
        return handler.mutableData.externalBlockGenerator.makeGenCallback(handler.session.project.configEx, handler.tmdDocInfo.doc, custom);
    }

    fn getLinkUrlGenCallback(ctx: *const anyopaque, link: *const tmd.Link) !?tmd.GenCallback {
        const handler: *const @This() = @ptrCast(@alignCast(ctx));

        const url = link.url.?;
        const targetPath, const fragment = switch (url.manner) {
            .relative => |v| blk: {
                if (v.extension) |ext| switch (ext) {
                    .tmd => {
                        std.debug.assert(v.isTmdFile());

                        const absPath = try util.resolvePathFromFilePath(handler.tmdDocInfo.sourceFilePath, url.base, true, handler.session.arenaAllocator);
                        break :blk .{ try handler.session.tryToRegisterFile(.{ .local = absPath }, .contentArticle), url.fragment };
                    },
                    .txt, .html, .htm, .xhtml, .css, .js => {
                        try handler.session.appContext.stderr.print("Liking to .html/.htm/.xhtml/.css/.js fiels is not supported now: {s}\n", .{url.base});
                        return error.NotImplementedYet;
                    },
                    .png, .gif, .jpg, .jpeg => {
                        const absPath = try util.resolvePathFromFilePath(handler.tmdDocInfo.sourceFilePath, url.base, true, handler.session.arenaAllocator);
                        break :blk .{ try handler.session.tryToRegisterFile(.{ .local = absPath }, .images), "" };
                    },
                };

                return null;
            },
            else => return null,
        };

        // ToDo: standalone-html build needs different handling.

        return handler.mutableData.relativePathWriter.asGenBacklback(
            targetPath,
            std.fs.path.sep,
            handler.tmdDocInfo.targetFilePath,
            std.fs.path.sep,
            fragment,
        );
    }

    fn getMediaUrlGenCallback(ctx: *const anyopaque, link: *const tmd.Link) !?tmd.GenCallback {
        const handler: *const @This() = @ptrCast(@alignCast(ctx));

        const url = link.url.?;
        const targetPath = switch (url.manner) {
            .relative => blk: {
                const absPath = try util.resolvePathFromFilePath(handler.tmdDocInfo.sourceFilePath, url.base, true, handler.session.arenaAllocator);
                break :blk try handler.session.tryToRegisterFile(.{ .local = absPath }, .images);
            },
            else => return null,
        };

        return handler.mutableData.relativePathWriter.asGenBacklback(
            targetPath,
            std.fs.path.sep,
            handler.tmdDocInfo.targetFilePath,
            std.fs.path.sep,
            "",
        );
    }
};

const FilePurpose = enum {
    navigationArticle, // tmd file
    contentArticle, // tmd file
    //html,
    images,
    css,
    js,
};

pub const StaticWebsiteBuilder = struct {
    //const Context = struct {
    //    //outputDir: std.fs.Dir,
    //    //outputArticlesDir: std.fs.Dir,
    //    //outputImagesDir: std.fs.Dir,
    //    //outputCssDir: std.fs.Dir,
    //};
    //
    //fn initContextFor(session: *const BuildSession) !void {
    //    const ctx = try session.arenaAllocator.create(Context);
    //    //const outputDir = try std.fs.openDirAbsolute(session.buildOutputPath, .{});
    //    //ctx.* = {
    //    //    .outputDir = outputDir,
    //    //    .outputArticlesDir = try outputDir.makeOpenPath(articlesDirname),
    //   //    .outputImagesDir = try outputDir.makeOpenPath(imagesDirname),
    //    //    .outputCssDir = try outputDir.makeOpenPath(cssDirname),
    //    //};
    //    session.builderContext = ctx;
    //}
    //
    //fn deinitContextFor(session: *const BuildSession) void {
    //    const ctx = @ptrCast(@alignCast(session.builderContext));
    //    //ctx.outputArticlesDir.close();
    //    //ctx.outputImagesDir.close();
    //    //ctx.outputCssDir.close();
    //    //ctx.outputDir.close();
    //    _ = ctx;
    //}

    fn buildNameSuffix() []const u8 {
        return ""; // "-website";
    }

    fn calTargetFilePath(session: *BuildSession, filePath: Config.FilePath, filePurpose: FilePurpose) ![]const u8 {
        switch (filePurpose) {
            .navigationArticle, .contentArticle => {
                switch (filePath) {
                    .local => |sourceAbsPath| {
                        const project = session.project;
                        if (!util.isFileInDir(sourceAbsPath, project.path)) {
                            try session.appContext.stderr.print("Article file must be in project path ({s}): {s}.\n", .{ session.project.path, sourceAbsPath });
                            return error.FileOutOfProject;
                        }

                        const relPath = sourceAbsPath[project.path.len + 1 ..];
                        const ext = std.fs.path.extension(relPath);
                        const targetPath = try std.mem.concat(session.arenaAllocator, u8, &.{ relPath[0 .. relPath.len - ext.len], ".html" });
                        if (builtin.mode == .Debug) std.debug.assert(session.targetFileContents.get(targetPath) == null);

                        //try session.targetFileContents.put(targetPath, ""); // Don't
                        return targetPath;
                    },
                    .builtin, .remote => unreachable,
                }
            },
            //.html => {
            //    const project = session.project;
            //    if (!util.isFileInDir(sourceAbsPath, project.path)) {
            //        try session.appContext.stderr.print("Article file must be in project path ({s}): {s}.\n", .{ session.project.path, sourceAbsPath });
            //        return error.FileOutOfProject;
            //    }
            //
            //    const relPath = sourceAbsPath[project.path.len + 1 ..];
            //    return try std.fs.path.join(session.arenaAllocator, &.{ "@html", relPath });
            //},
            inline .images, .css, .js => |tag| {
                const folderName = "@assets" ++ &[1]u8{std.fs.path.sep} ++ @tagName(tag);

                switch (filePath) {
                    .builtin => |name| {
                        const info = try session.appContext.getBuiltinFileInfo(name);

                        const targetPath = try util.buildAssetFilePath(folderName, std.fs.path.sep, name, info.content, session.arenaAllocator);
                        if (builtin.mode == .Debug) std.debug.assert(session.targetFileContents.get(targetPath) == null);

                        try util.writeFile(session.buildOutputDir, targetPath, info.content);

                        try session.targetFileContents.put(targetPath, "");
                        return targetPath;
                    },
                    .local => |sourceAbsPath| {
                        const content = try util.readFile(std.fs.cwd(), sourceAbsPath, .{ .alloc = .{ .allocator = session.appContext.allocator, .maxFileSize = maxAssetFileSize } }, session.appContext.stderr);
                        defer session.appContext.allocator.free(content);

                        const targetPath = try util.buildAssetFilePath(folderName, std.fs.path.sep, std.fs.path.basename(sourceAbsPath), content, session.arenaAllocator);
                        if (builtin.mode == .Debug) std.debug.assert(session.targetFileContents.get(targetPath) == null);

                        try util.writeFile(session.buildOutputDir, targetPath, content);

                        try session.targetFileContents.put(targetPath, "");
                        return targetPath;
                    },
                    .remote => unreachable,
                }
            },
        }
    }

    fn generateArticleContent(session: *BuildSession, absPath: []const u8, relPath: []const u8, tmdDocRenderer: *DocRenderer) ![]const u8 {
        const navDoc, const pCollected = switch (session.navArticleInfo) {
            .manuallySpecified => |*info| if (info.collected) .{ null, undefined } else .{ info.tmdDoc, &info.collected },
            .autoGenerated => .{ null, undefined },
        };
        defer if (navDoc != null) {
            pCollected.* = true;
        };

        const tmdDoc, const renderBuffer = if (navDoc) |doc| .{ doc, session.genBuffer } else blk: {
            var remainingBuffer = session.genBuffer;

            const tmdContent = try util.readFile(std.fs.cwd(), absPath, .{ .buffer = remainingBuffer[0..maxTmdFileSize] }, session.appContext.stderr);
            remainingBuffer = remainingBuffer[tmdContent.len..];

            var fba = std.heap.FixedBufferAllocator.init(remainingBuffer);
            const fbaAllocator = fba.allocator();
            const tmdDoc = try tmd.Doc.parse(tmdContent, fbaAllocator);
            remainingBuffer = remainingBuffer[fba.end_index..];

            break :blk .{ tmdDoc, remainingBuffer };
        };

        var w: std.Io.Writer = .fixed(renderBuffer);

        try tmdDocRenderer.render(&w, .{
            .doc = &tmdDoc,
            .sourceFilePath = absPath,
            .targetFilePath = relPath,
        });

        const htmlContent = w.buffered();

        try util.writeFile(session.buildOutputDir, relPath, htmlContent);

        //const htmlContent2 = try session.arenaAllocator.dupe(u8, htmlContent);
        //return htmlContent2;
        return ""; // no need to cache it, because it has been written.
    }

    fn createDocRendererCallbacks(session: *BuildSession) DocRenderer.Callbacks {
        const T = struct {
            fn relativeUrlInAttributeCallback(owner: *anyopaque, r: *const DocRenderer, filePath: Config.FilePath) !void {
                const bs: *BuildSession = @ptrCast(@alignCast(owner));

                const tmdDocInfo = if (r.tmdDocInfo) |info| info else unreachable;

                switch (filePath) {
                    .builtin => @panic("relative-url-in-attribute with built-in assets is not supported now"),
                    .remote => |url| try tmd.writeUrlAttributeValue(r.w, url),
                    .local => |absPath| {
                        const ext = tmd.extension(absPath) orelse return error.UnrecognizedExtension;
                        const purpose: FilePurpose = switch (ext) {
                            .css,
                            => .css,
                            .js => .js,
                            else => blk: {
                                const info = tmd.getExtensionInfo(ext);
                                if (!info.isImage) return error.UnsupportedFileFormat;
                                break :blk .images;
                            },
                        };

                        const targetPath = try bs.tryToRegisterFile(.{ .local = absPath }, purpose);

                        try gen.writeRelativeUrl(r.w, targetPath, std.fs.path.sep, tmdDocInfo.targetFilePath, std.fs.path.sep);
                    },
                }
            }

            fn assetElementsInHeadCallback(owner: *anyopaque, r: *const DocRenderer) !void {
                const bs: *BuildSession = @ptrCast(@alignCast(owner));
                try bs.writeAssetElementLinksInHead(r.w, r.tmdDocInfo.?.targetFilePath, std.fs.path.sep);
            }

            fn pageTitleInHeadCallback(owner: *anyopaque, r: *const DocRenderer) !void {
                const bs: *BuildSession = @ptrCast(@alignCast(owner));

                const tmdDocInfo = if (r.tmdDocInfo) |info| info else unreachable;

                if (!try tmdDocInfo.doc.writePageTitle(r.w, .inHtmlHead)) {
                    try r.w.writeAll("Untitled"); // ToDo: localization
                }

                switch (bs.navArticleInfo) {
                    .manuallySpecified => {},
                    .autoGenerated => |*info| {
                        const zero: u32 = 0;

                        const wa = &info.tocItemBuffer;
                        const w = &wa.writer;
                        try w.writeInt(u32, @intCast(info.index), .little);
                        info.index += 1;

                        var offset = wa.written().len;
                        try w.writeInt(u32, zero, .little); // title length
                        var offset2 = wa.written().len;
                        if (!try tmdDocInfo.doc.writePageTitle(w, .htmlTocItem)) {
                            try r.w.writeAll("Untitled"); // ToDo: localization
                        }
                        var wTitleLen: std.Io.Writer = .fixed(wa.written()[offset..offset2]);
                        try wTitleLen.writeInt(u32, @intCast(wa.written().len - offset2), .little);

                        offset = wa.written().len;
                        try w.writeInt(u32, zero, .little); // link length
                        offset2 = wa.written().len;
                        try r.w.writeAll(tmdDocInfo.targetFilePath);
                        var wUrlLen: std.Io.Writer = .fixed(wa.written()[offset..offset2]);
                        try wUrlLen.writeInt(u32, @intCast(wa.written().len - offset2), .little);
                    },
                }
            }

            fn pageContentInBodyCallback(owner: *anyopaque, r: *const DocRenderer) !void {
                const bs: *BuildSession = @ptrCast(@alignCast(owner));

                const tmdDocInfo = if (r.tmdDocInfo) |info| info else unreachable;

                var mutableData: TmdGenCustomHandler.MutableData = undefined;
                var tmdGenCustomHandler: TmdGenCustomHandler = .init(bs, tmdDocInfo, &mutableData);
                const genOptions = tmdGenCustomHandler.makeTmdGenOptions();

                try tmdDocInfo.doc.writeHTML(r.w, genOptions, bs.appContext.allocator);
            }

            fn navContentInBodyCallback(owner: *anyopaque, r: *const DocRenderer) !void {
                const bs: *BuildSession = @ptrCast(@alignCast(owner));

                const tmdDocInfo = if (r.tmdDocInfo) |info| info else unreachable;

                switch (bs.navArticleInfo) {
                    .manuallySpecified => |info| {
                        const navTmdDoc = &info.tmdDoc;

                        const navDocInfo: @TypeOf(tmdDocInfo) = .{
                            .doc = navTmdDoc,
                            .sourceFilePath = bs.articleFiles.items[0],
                            .targetFilePath = tmdDocInfo.targetFilePath,
                        };

                        var mutableData: TmdGenCustomHandler.MutableData = undefined;
                        var tmdGenCustomHandler: TmdGenCustomHandler = .init(bs, navDocInfo, &mutableData);
                        const genOptions = tmdGenCustomHandler.makeTmdGenOptions();

                        try navTmdDoc.writeHTML(r.w, genOptions, bs.appContext.allocator);
                    },
                    .autoGenerated => {
                        // .tocItemBuffer.writer.flush(); // no-op
                        // Just cache html snippets, then write full pages in the end.
                        return;
                    },
                }

            }
        };

        return .{
            .owner = session,
            .relativeUrlInAttributeCallback = T.relativeUrlInAttributeCallback,
            .assetElementsInHeadCallback = T.assetElementsInHeadCallback,
            .pageTitleInHeadCallback = T.pageTitleInHeadCallback,
            .pageContentInBodyCallback = T.pageContentInBodyCallback,
            .navContentInBodyCallback = T.navContentInBodyCallback,
        };
    }

    fn assembleOutputFiles(session: *BuildSession) !void {
        _ = session;
    }
};

pub const EpubBuilder = struct {
    // .tmd -> .xhtml
    // image.ext -> images/image-HASH.ext
    // .css -> .css

    fn buildNameSuffix() []const u8 {
        return ".epub";
    }

    fn calTargetFilePath(session: *BuildSession, filePath: Config.FilePath, filePurpose: FilePurpose) ![]const u8 {
        switch (filePurpose) {
            .navigationArticle => {
                switch (filePath) {
                    .local => |sourceAbsPath| {
                        const project = session.project;
                        if (!util.isFileInDir(sourceAbsPath, project.path)) {
                            try session.appContext.stderr.print("Article file must be in project path ({s}): {s}.\n", .{ session.project.path, sourceAbsPath });
                            return error.FileOutOfProject;
                        }
                        const basename = std.fs.path.basename(sourceAbsPath);
                        const ext = std.fs.path.extension(basename);
                        const targetPath = try std.mem.concat(session.arenaAllocator, u8, &.{ basename[0 .. basename.len - ext.len], ".xhtml" });
                        if (builtin.mode == .Debug) std.debug.assert(session.targetFileContents.get(targetPath) == null);

                        //try session.targetFileContents.put(targetPath, ""); // Don't
                        return targetPath;
                    },
                    .builtin, .remote => unreachable,
                }
            },
            .contentArticle => {
                switch (filePath) {
                    .local => |sourceAbsPath| {
                        const project = session.project;
                        if (!util.isFileInDir(sourceAbsPath, project.path)) {
                            try session.appContext.stderr.print("Article file must be in project path ({s}): {s}.\n", .{ session.project.path, sourceAbsPath });
                            return error.FileOutOfProject;
                        }

                        const relPath = sourceAbsPath[project.path.len + 1 ..];
                        const ext = std.fs.path.extension(relPath);
                        const targetPath = try util.buildPosixPath("tmd/", relPath[0 .. relPath.len - ext.len], ".xhtml", session.arenaAllocator);
                        if (builtin.mode == .Debug) std.debug.assert(session.targetFileContents.get(targetPath) == null);

                        //try session.targetFileContents.put(targetPath, ""); // Don't
                        return targetPath;
                    },
                    .builtin, .remote => unreachable,
                }
            },
            //.html => {
            //    const project = session.project;
            //    if (!util.isFileInDir(sourceAbsPath, project.path)) {
            //        try session.appContext.stderr.print("Article file must be in project path ({s}): {s}.\n", .{ session.project.path, sourceAbsPath });
            //        return error.FileOutOfProject;
            //    }
            //    const relPath = sourceAbsPath[project.path.len + 1 ..];
            //    const ext = std.fs.path.extension(relPath);
            //    const targetPath = util.buildPosixPath("html/", relPath[0 .. relPath.len - ext.len], ".xhtml", session.arenaAllocator);
            //
            //    return targetPath;
            //},
            inline .images, .css, .js => |tag| {
                const folderName = @tagName(tag) ++ "/";

                switch (filePath) {
                    .builtin => |name| {
                        const info = try session.appContext.getBuiltinFileInfo(name);

                        const targetPath = try util.buildPosixPathWithContentHashBase64(folderName, name, info.content, session.arenaAllocator);
                        if (builtin.mode == .Debug) std.debug.assert(session.targetFileContents.get(targetPath) == null);

                        try session.targetFileContents.put(targetPath, info.content);
                        return targetPath;
                    },
                    .local => |sourceAbsPath| {
                        const content = try util.readFile(std.fs.cwd(), sourceAbsPath, .{ .alloc = .{ .allocator = session.arenaAllocator, .maxFileSize = maxAssetFileSize } }, session.appContext.stderr);

                        const targetPath = try util.buildPosixPathWithContentHashBase64(folderName, std.fs.path.basename(sourceAbsPath), content, session.arenaAllocator);
                        if (builtin.mode == .Debug) std.debug.assert(session.targetFileContents.get(targetPath) == null);

                        try session.targetFileContents.put(targetPath, content);
                        return targetPath;
                    },
                    .remote => unreachable,
                }
            },
        }
    }

    fn generateArticleContent(session: *BuildSession, absPath: []const u8, relPath: []const u8, tmdDocRenderer: *DocRenderer) ![]const u8 {
        _ = session;
        _ = absPath;
        _ = relPath;
        _ = tmdDocRenderer;

        return "";
    }

    fn createDocRendererCallbacks(session: *BuildSession) DocRenderer.Callbacks {
        const T = struct {
            fn assetElementsInHeadCallback(owner: *anyopaque, r: *const DocRenderer) !void {
                const bs: *BuildSession = @ptrCast(@alignCast(owner));
                try bs.writeAssetElementLinksInHead(r.w, r.tmdDocInfo.?.targetFilePath, '/');
            }

            fn pageTitleInHeadCallback(owner: *anyopaque, r: *const DocRenderer) !void {
                const bs: *BuildSession = @ptrCast(@alignCast(owner));
                _ = bs;

                if (r.tmdDocInfo) |info| {
                    if (try info.doc.writePageTitle(r.w, .inHtmlHead)) return;
                }
                try r.w.writeAll("Untitled");
            }

            fn pageContentInBodyCallback(owner: *anyopaque, r: *const DocRenderer) !void {
                const bs: *BuildSession = @ptrCast(@alignCast(owner));
                _ = bs;
                _ = r;
            }
        };

        return .{
            .owner = session,
            .assetElementsInHeadCallback = T.assetElementsInHeadCallback,
            .pageTitleInHeadCallback = T.pageTitleInHeadCallback,
            .pageContentInBodyCallback = T.pageContentInBodyCallback,
        };
    }

    fn assembleOutputFiles(session: *BuildSession) !void {
        _ = session;
    }
};

pub const StandaloneHtmlBuilder = struct {
    // .tmd -> #foo/bar.tmd
    // image.ext -> inline base64 string
    // .css -> inline

    fn buildNameSuffix() []const u8 {
        return "-standalone.html";
    }

    fn calTargetFilePath(session: *BuildSession, filePath: Config.FilePath, filePurpose: FilePurpose) ![]const u8 {
        switch (filePurpose) {
            .navigationArticle,
            .contentArticle, //, .html
            => {
                switch (filePath) {
                    .local => |sourceAbsPath| {
                        const project = session.project;
                        if (!util.isFileInDir(sourceAbsPath, project.path)) {
                            try session.appContext.stderr.print("Article file must be in project path ({s}): {s}.\n", .{ session.project.path, sourceAbsPath });
                            return error.FileOutOfProject;
                        }
                        const targetPath = try std.mem.concat(session.arenaAllocator, u8, &.{ "#", sourceAbsPath[project.path.len + 1 ..] });
                        if (builtin.mode == .Debug) std.debug.assert(session.targetFileContents.get(targetPath) == null);

                        //try session.targetFileContents.put(targetPath, ""); // Don't
                        return targetPath;
                    },
                    .builtin, .remote => unreachable,
                }
            },
            .images => {
                switch (filePath) {
                    .builtin => |name| {
                        const info = try session.appContext.getBuiltinFileInfo(name);

                        const targetPath = try util.buildEmbeddedImageHref(info.extension, info.content, session.arenaAllocator);
                        if (builtin.mode == .Debug) std.debug.assert(session.targetFileContents.get(targetPath) == null);

                        try session.targetFileContents.put(targetPath, "");
                        return targetPath;
                    },
                    .local => |sourceAbsPath| {
                        const content = try util.readFile(std.fs.cwd(), sourceAbsPath, .{ .alloc = .{ .allocator = session.appContext.allocator, .maxFileSize = maxAssetFileSize } }, session.appContext.stderr);
                        defer session.appContext.allocator.free(content);

                        const ext = tmd.extension(sourceAbsPath) orelse unreachable;
                        const info = tmd.getExtensionInfo(ext);
                        if (!info.isImage) unreachable;

                        const targetPath = try util.buildEmbeddedImageHref(ext, content, session.arenaAllocator);
                        if (builtin.mode == .Debug) std.debug.assert(session.targetFileContents.get(targetPath) == null);

                        try session.targetFileContents.put(targetPath, "");
                        return targetPath;
                    },
                    .remote => unreachable,
                }
            },
            .css, .js => {
                switch (filePath) {
                    .builtin => |name| {
                        const info = try session.appContext.getBuiltinFileInfo(name);

                        const targetPath = try util.buildHashString(info.content, session.arenaAllocator);
                        if (builtin.mode == .Debug) std.debug.assert(session.targetFileContents.get(targetPath) == null);

                        try session.targetFileContents.put(targetPath, info.content);
                        return targetPath;
                    },
                    .local => |sourceAbsPath| {
                        const content = try util.readFile(std.fs.cwd(), sourceAbsPath, .{ .alloc = .{ .allocator = session.appContext.arenaAllocator, .maxFileSize = maxAssetFileSize } }, session.appContext.stderr);
                        defer session.appContext.allocator.free(content);

                        const targetPath = try util.buildHashString(content, session.arenaAllocator);
                        if (builtin.mode == .Debug) std.debug.assert(session.targetFileContents.get(targetPath) == null);

                        try session.targetFileContents.put(targetPath, content);
                        return targetPath;
                    },
                    .remote => unreachable,
                }
            },
        }
    }

    fn generateArticleContent(session: *BuildSession, absPath: []const u8, relPath: []const u8, tmdDocRenderer: *DocRenderer) ![]const u8 {
        _ = session;
        _ = absPath;
        _ = relPath;
        _ = tmdDocRenderer;

        return "";
    }

    fn createDocRendererCallbacks(session: *BuildSession) DocRenderer.Callbacks {
        const T = struct {
            fn assetElementsInHeadCallback(owner: *anyopaque, r: *const DocRenderer) !void {
                const bs: *BuildSession = @ptrCast(@alignCast(owner));
                _ = bs;
                _ = r;
            }

            fn pageTitleInHeadCallback(owner: *anyopaque, r: *const DocRenderer) !void {
                const bs: *BuildSession = @ptrCast(@alignCast(owner));
                _ = bs;
                _ = r;
            }

            fn pageContentInBodyCallback(owner: *anyopaque, r: *const DocRenderer) !void {
                const bs: *BuildSession = @ptrCast(@alignCast(owner));
                _ = bs;
                _ = r;
            }
        };

        return .{
            .owner = session,
            .assetElementsInHeadCallback = T.assetElementsInHeadCallback,
            .pageTitleInHeadCallback = T.pageTitleInHeadCallback,
            .pageContentInBodyCallback = T.pageContentInBodyCallback,
        };
    }

    fn assembleOutputFiles(session: *BuildSession) !void {
        _ = session;
    }
};

// For build
// step 1: copy css/favicon and rename them with hash in names.
//         tfcc needs a .outputDir field, a cssFilesInHead fields (relative to .outputDir).
// step 2: collect titles for TOC.
// step 2: render all tmd files and write html files.
//         During writing, calculate relative css and favicon urls in head.
//         tfcc needs a "image url rewritten callback" field, a "article url broken check callback" field.
//         copy images and rename them with hash in names during rewriting image urls.
//         - for "static-website", save each html as a file.
//         - for "epub" and "standalone-html", saving all to one file.
//         - for "standalone-html", write embedding image base64, and write embedding css style.
//
// For gen:
// step 1: render all tmd files and write html files.
//         During writing, calculate relative css and favicon urls in head. (for full generation).

// If "project-navigation-file" is specified, use it as the seed file.
// Otherwise, iterate all tmd files in project dir.
// The navigation article must be in the project dir.

// Referencing articles outside project dir is a broken-link.

// Missing referenced assets is not a fatal error.

// Need to collect referenced asset file paths, to copy them to @tmd-build dir with hash in the new file names.
// Referenced asset href src paths will be rewritten, and a map from old to new is built.
// The built map will be passed to TapirMD core lib for rendering the new paths in a-href and image-src.

// Directories which paths (relative to workspace) containing "@xxx" is ignored in tmd file scanning.

// If the workspace directory is not found, then the project directory is viewed as the workspace directory.

// Missing tmd.project file will make a default one (Project title is defaulted to the containing directory name).

// Project name is generated from project title and config file name.

// workspace-dir
//  @tmd-build
//    project-name-VERSION-html/
//    project-name-VERSION.epub
//    project-name-VERSION-standalone.html
//
//    project-name-trial-VERSION-html/
//    project-name-trial-VERSION.epub
//    project-name-trial-VERSION-standalone.html
